% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/redis_multisession.R
\name{redis_multisession}
\alias{redis_multisession}
\title{Redis-based localhost multisession futures}
\usage{
redis_multisession(
  expr,
  substitute = TRUE,
  envir = parent.frame(),
  ...,
  workers = availableCores(),
  queue = getOption("future.redis.queue", "{{session}}"),
  config = redis_config(),
  output_queue = NA_character_,
  max_retries = 3L
)
}
\arguments{
\item{expr}{An \R \link[base]{expression}.}

\item{substitute}{If TRUE, argument \code{expr} is
\code{\link[base]{substitute}()}:ed, otherwise not.}

\item{envir}{The \link{environment} from where global objects should be
identified.}

\item{...}{Additional named elements of the future.}

\item{workers}{A positive numeric scalar or a function specifying the
maximum number of parallel futures that can be active at the same time
before blocking.
If a function, it is called without arguments \emph{when the future
is created} and its value is used to configure the workers.
The function should return a numeric scalar.}

\item{queue}{A Redis key name of the task queue, or a
\code{RedisWorkerConfiguration} object as returned by \code{\link[=startLocalWorkers]{startLocalWorkers()}}.}

\item{config}{A \link[redux:redis_config]{redux::redis_config} Redis configuration object.}

\item{output_queue}{(optional) Redis key name of the work output queue
(note: reserved for future use).}

\item{max_retries}{Maximum number of times the future can be re-submitted
to the task queue in the event of failure.}
}
\value{
An object of class \link{RedisFuture}.
}
\description{
Redis-based localhost multisession futures
}
\examples{
## The example assumes that a Redis server is running
## on the local host and the standard Redis port (6379)
if (redux::redis_available()) {

# Start two local R worker processes running in the background
workers <- startLocalWorkers(2L, linger = 1.0)

plan(redis, workers = workers)

# A function that returns a future, note that N uses lexical scoping...
f <- \() future({4 * sum((runif(N) ^ 2 + runif(N) ^ 2) < 1) / N}, seed = TRUE)

# Run a simple sampling approximation of pi in parallel using  M * N points:
N <- 1e6  # samples per worker
M <- 10   # iterations
pi_est <- Reduce(sum, Map(value, replicate(M, f()))) / M
print(pi_est)

# Make sure to stop the workers
stopLocalWorkers(workers)

}
}
\seealso{
\code{\link[redux:redis_config]{redux::redis_config()}}, \code{\link[=redis]{redis()}}
}
